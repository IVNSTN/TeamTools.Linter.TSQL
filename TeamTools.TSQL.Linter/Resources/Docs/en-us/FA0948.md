

# Implicit conversion is impossible

|||
|-|-|
| Id | **FA0948**
| Mnemo | ILLEGAL_IMPLICIT_CONVERSION
| Severity | ⛔ Error
| Category | [Failure](./Category_Failure.md)
| Source code | [ImplicitConversionImpossibleRule.cs](../../../Rules/Failure/ImplicitConversionImpossibleRule.cs)

## Cause

The rule is triggered if an implicit conversion from one type to another type is not possible.
<p id="descr">Specify the correct type of variable to convert.</p>

## Examples

Bad

```sql
DECLARE @notastring INT;
SET @notastring = '1';
SELECT @notastring + ' is not a string.'
```

Good

```sql
DECLARE @string VARCHAR(10);
SET @string = 1;
SELECT @string + ' is a string.'
```

## Tips

💡 Use an explicit conversion if it is acceptable, or fix the type incompatibility error.

💡 Since the linter works within a single file, it knows nothing about user types and result types of user functions and therefore does not validate them.

💡 Some comments on the definition of the final type of expression:

    1. ISNULL returns the type equal to the type of the first argument
    2. NULLIF actually returns NULL with a type equal to the type of the first argument when the values match; in the calculation process, it converts both parameters to the type with the maximum priority and if the values are not equal, that leaves the result in a new type (although the documentation says that the value is always returned in the type of the first argument; see the example below)
    3. CASE, COALESCE (which is essentially syntactic sugar to replace CASE) calculate the highest priority type from all arguments or variants of the result (THEN, ELSE), each argument or variant of the result (THEN, ELSE) must be compatible only with this calculated type.
    4. BETWEEN is syntactic sugar for substitution (>= AND <=), so the value being checked separately must be compatible with the type of each boundary.
    5. all numeric types can be converted explicitly or implicitly to DATETIME, but not to DATETIME2, DATE, or TIME
    6. with rare exceptions, all types can be implicitly converted to SQL_VARIANT, but only explicit conversions are possible in the opposite direction.
    7. date and time types, as well as SQL_VARIANT, occupy the highest places in the list of type priorities, so be careful when writing expressions, where these types and some others are involved - if you forget about explicit conversions to the desired type, everything will be converted to the types with the highest priority (integers will turn into dates or all into SQL_VARIANT)
    8. all integer types allow implicit conversions to each other, just like string types, if the value size of one data type exceeds the allowed size of another data type it will lead to error: OUT OF RANGE or IMPLICIT TRUNCATION. Be careful when combining different types in one expression!

💡 An example to explain the work of NULLIF:

```sql
DECLARE @var TINYINT = 1;
--there is a match, NULLIF will return TINYINT and ISNULL will fall off with Arithmetic Overflow
SELECT ISNULL(NULLIF(@var, 1), -1)
GO

DECLARE @var TINYINT = 1;
-- the values did not match, moreover, in order to compare them, we had to convert TINYINT to INT
-- NULLIF will eventually return the original 1, but already in the INT and IS NULL type will not lead to an error
SELECT ISNULL(NULLIF(@var, 300), -1)
```

## Links

[Matrix of possible transformations](https://learn.microsoft.com/en-us/sql/t-sql/data-types/data-type-conversion-database-engine?view=sql-server-ver16)

[Priority of types](https://learn.microsoft.com/en-us/sql/t-sql/data-types/data-type-precedence-transact-sql?view=sql-server-ver16)