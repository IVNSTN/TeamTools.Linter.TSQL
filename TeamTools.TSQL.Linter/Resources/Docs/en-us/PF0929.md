
# Non-sargable predicate

|||
|-|-|
| Id | **PF0929**
| Mnemo | NON_SARGABLE_PREDICATE
| Severity | ℹ Hint
| Category | [Performance](./Category_Performance.md)
| Source code | [NonSargablePredicateRule.cs](../../../Rules/Performance/NonSargablePredicateRule.cs)

## Cause

This rule is triggered if filtering (`WHERE`) and joining (`JOIN`) predicates that cannot be efficiently calculated and applied to existing indexes are detected.
<p id="descr">Rewrite the predicate so that it can be applied to existing indexes.</p>

## Examples

Bad

```sql
-- Calculating:
SELECT
    ft.id
    , ft.val
FROM dbo.foo AS ft
INNER JOIN dbo.bar AS bt
    ON bt.id = ft.id + 1 -- here
WHERE (ft.num - bt.num) = 0; -- here

DELETE bt
FROM dbo.foo AS ft
INNER JOIN dbo.bar AS bt
    ON bt.id = CASE WHEN ft.parent_id IS NULL THEN bt.id ELSE ft.parent_id END -- here, CASE expression
WHERE ft.num = IIF(1 = 0, bt.num, NULL); -- here, function IIF

-- Call user defined functions:
SELECT
    ft.id
    , bt.val
FROM dbo.foo AS ft
INNER JOIN dbo.bar AS bt
    ON ft.id > dbo.min_id() -- here, function min_id()
WHERE ft.date_open BETWEEN dbo.yesterday() AND GETDATE(); -- here, function yesterday()

-- Type conversion:
SELECT
    ft.id
    , bt.val
FROM dbo.foo AS ft
INNER JOIN dbo.bar AS bt
    ON bt.id = CAST(ft.id AS BIGINT) -- here
WHERE TRY_CONVERT(DATE, ft.num) > 0; -- here

-- Working with NULL:
SELECT
    ft.id
    , bt.val
FROM dbo.foo AS ft
INNER JOIN dbo.bar AS bt
    ON ISNULL(ft.id, 0) <> bt.id -- here
WHERE NULLIF(t.title, '') <> ''; -- here
```

## Tips

💡 This includes:

- Calling non-deterministic functions or functions that depend on column values from the result set.
- Comparisons based on calculations or transformations of column values.
- Using logical `OR` applied to a filter on a column.
- Using `ISNULL`, `NULLIF`, `COALESCE`, `CAST`, `CONVERT` on a table column.

💡 Potential solutions include:

- Performing pre-transformations or aggregating data fragments in temporary tables.
- Expanding functions using `APPLY`.
- Replacing `ISNULL` or `NULLIF` with `OR` (though not ideal, this can sometimes be optimized through recompilation or `OPTIMIZE FOR` hints).
- Using filtered indexes.
- Decomposing complex queries into several simpler ones.
- And other optimization techniques.

💡 A comprehensive comparison that accounts for `NULL` as a distinct value can be performed using `EXCEPT`. To check for complete matches, use `INTERSECT`.
