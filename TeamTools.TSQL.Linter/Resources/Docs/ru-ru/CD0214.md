

# Ограничение использует 'IN' для списка значений

|||
|-|-|
| Id | **CD0214**
| Мнемо | LIST_IN_CONSTRAINT
| Серьёзность | ⚠ Предупреждение
| Категория | [НепрерывнаяПоставка](./Категория_НепрерывнаяПоставка.md)
| Исходный код | [ConstraintWithoutListsRule.cs](../../../Rules/ContinuousDeployment/ConstraintWithoutListsRule.cs)

## Причина

Правило срабатывает, если в ограничении используется `IN` с перечислением допустимых значений.
<p id="descr">Поменяйте IN на перечисление значений через OR.</p>

## Примеры

Некорректно

```sql
CREATE TABLE a
(
    b     INT     NOT NULL DEFAULT 1
    , c   CHAR(1) NULL     DEFAULT 'd'
    , bar INT NOT NULL
    , CONSTRAINT cs CHECK (bar IN (2, 3))
    , CONSTRAINT PK_a PRIMARY KEY (b)
);
GO
```

Корректно

```sql
CREATE TABLE a
(
    b     INT     NOT NULL DEFAULT 1
    , c   CHAR(1) NULL     DEFAULT 'd'
    , bar INT NOT NULL
    , CONSTRAINT cs CHECK (bar = 2 OR bar = 3)
    , CONSTRAINT PK_a PRIMARY KEY (b)
);
GO
```

## Подсказки

💡 На временные таблицы (#) и табличные переменные (@) не срабатывает.

💡 В ограничениях `CHECK` удобно указывать `IN` с перечислением допустимых значений и это корректная конструкция, однако DacFx по какой-то причине не умеет сопоставлять `IN` в проекте с `IN` на сервере и такие констрейнты попадают в "вечный дифф", хотя ничего не меняется.
