

# Неявное преобразование невозможно

|||
|-|-|
| Id | **FA0948**
| Мнемо | ILLEGAL_IMPLICIT_CONVERSION
| Серьёзность | ⛔ Ошибка
| Категория | [Сбой](./Категория_Сбой.md)
| Исходный код | [ImplicitConversionImpossibleRule.cs](../../../Rules/Failure/ImplicitConversionImpossibleRule.cs)

## Причина

Правило срабатывает, если неявное преобразование из одного типа во второй невозможно.
<p id="descr">Укажите правильный тип переменной для преобразования.</p>

## Примеры

Некорректно

```sql
DECLARE @notastring INT;
SET @notastring = '1';
SELECT @notastring + ' is not a string.'
```

Корректно

```sql
DECLARE @string VARCHAR(10);
SET @string = 1;
SELECT @string + ' is a string.'
```

## Подсказки

💡 Используйте явное преобразование, если оно допустимо, или устраните ошибку несовместимости типов.

💡 Поскольку линтер работает в пределах одного файла, про пользовательские типы и типы результата пользовательских функций он ничего не знает и потому на них не ругается.

💡 Некоторые комментарии по определению итогового типа выражения:

1. `ISNULL` возвращает тип, равный типу первого аргумента
2. `NULLIF` фактически при совпадении значений возвращает `NULL` с типом, равным типу первого аргумента; в процессе вычислений приводит оба параметра к типу с максимальным приоритетом и, если значения не равны, то оставляет результат в новом типе (хотя документация говорит, что всегда возвращается значение в типе первого аргумента; см. пример ниже)
3. `CASE`, `COALESCE` (который, по сути, есть синтаксический сахар для замены `CASE`) вычисляют максимально приоритетный тип из всех аргументов или вариантов результата (`THEN`, `ELSE`), каждый аргумент или вариант результата (`THEN`, `ELSE`) должен быть совместим только с этим рассчитанным типом
4. `BETWEEN` - это синтаксический сахар для замены (`>= AND <=`), поэтому проверяемое значение по-отдельности должно быть совместимо с типом каждой границы, границы же между собой могут быть несовместимы; но это скорее не выигрыш, а еще одна точка возможного недопонимания фактического поведения
5. все числовые типы могут быть преобразованы явно или неявно в `DATETIME`, но не в `DATETIME2`, `DATE` или `TIME`
6. все типы, за редким исключением, могут быть неявно преобразованы в `SQL_VARIANT`, но в обратную сторону возможны только явные преобразования
7. типы с датой и временем, а также `SQL_VARIANT` занимают самые высокие строчки в перечне приоритетов типов, поэтому будьте осторожны при написании выражений, где участвуют эти типы и какие-то другие - если забыть про явные преобразования к нужному типу, всё будет преобразовано к типам с наивысшим приоритетом (целые превратятся в даты или всё в `SQL_VARIANT`)
8. все целочисленные типы допускают неявные преобразования друг к другу, как и строковые, однако это не отменяет то, что один тип может допускать значения, которые выйдут за пределы размера другого типа и возникнет `OUT OF RANGE` или `IMPLICIT TRUNCATION`. Будьте внимательны при совмещении разных типов в одном выражении!

💡 Пример для пояснения работы `NULLIF`:

```sql
DECLARE @var TINYINT = 1;
-- есть совпадение, NULLIF вернет TINYINT и ISNULL приведет к Arithemic Overflow
SELECT ISNULL(NULLIF(@var, 1), -1)
GO

DECLARE @var TINYINT = 1;
-- значения не совпали, более того, чтобы их сравнить, пришлось привести TINYINT к INT
-- NULLIF в итоге хоть и вернет изначальную 1, но уже в типе INT, и ISNULL не приведет к ошибке
SELECT ISNULL(NULLIF(@var, 300), -1)
```

## Ссылки

[Mатрица возможных преобразований](https://learn.microsoft.com/ru-ru/sql/t-sql/data-types/data-type-conversion-database-engine?view=sql-server-ver16)

[Приоритет типов](https://learn.microsoft.com/ru-ru/sql/t-sql/data-types/data-type-precedence-transact-sql?view=sql-server-ver16)
