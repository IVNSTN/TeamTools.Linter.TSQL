
# Ветвление кода на основе времени

|||
|-|-|
| Id | **MA0174**
| Мнемо | CLOCK_BASED_CODE_FLOW
| Серьёзность | ℹ Подсказка
| Категория | [Обслуживаемость](./Категория_Обслуживаемость.md)
| Исходный код | [ClockBasedCodeFlowRule.cs](../../../Rules/Maintainability/ClockBasedCodeFlowRule.cs)

## Причина

Правило срабатывает, если в коде обнаружено условие, использующее функции работы с текущими датой или временем.
<p id="descr">Удалите функции работы с текущими датой или временем из условия.</p>

## Примеры

Некорректно

```sql
IF SYSDATETIME() > '19990101'
    SELECT GETDATE(), SYSDATETIME(), @today

UPDATE t
SET
    dtupdate = SYSDATETIME()
FROM tbl AS t
WHERE close_date < GETDATE();
```

Корректно

```sql
SELECT GETDATE(), SYSDATETIME(), @today;

UPDATE t
SET
    dtupdate = SYSDATETIME()
FROM tbl AS t
WHERE close_date IS NULL;
```

## Подсказки

💡 Там, где код вынужденно анализирует дату и время, например, рабочее сейчас время или нет, рекомендуется выносить это в скалярную функцию. Такую функцию можно будет подменить в тестах, а не ждать наступления подходящего для запуска теста времени.

💡 Крайне желательно уходить от `IF-ELSE` к `STATE/STRATEGY`, например, на основе данных. Хранить время работы в "таблице-календаре" (таблице-расписании) и вычислять, какой нужен алгоритм действий по результату выборки из этой таблицы, а не из хардкода.
