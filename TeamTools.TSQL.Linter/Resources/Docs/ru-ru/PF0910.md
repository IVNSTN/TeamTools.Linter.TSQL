

# Индексация столбца, допускающего NULL или имеющего значение по умолчанию, без фильтрации по значению по умолчанию

|||
|-|-|
| Id | **PF0910**
| Мнемо | INDEXING_COL_WITH_DEFAULT
| Серьёзность | ℹ Подсказка
| Категория | [Производительность](./Категория_Производительность.md), [Индексы](./Группа_Индексы.md)
| Исходный код | [UniqueIndexOnColumnWithDefaultRule.cs](../../../Rules/Performance/UniqueIndexOnColumnWithDefaultRule.cs)

## Причина

<p id="descr">Если у колонки есть типовое значение, то индекс по этому полю будет иметь плохую селективность. Если исключить из индексации строки с типовым значением, то индекс станет гораздо более полезным.</p>

## Примеры

Некорректно

```sql
CREATE TABLE dbo.foo
(
    id          INT NOT NULL PRIMARY KEY
    , parent_id INT NOT NULL DEFAULT 0
    , UNIQUE (parent_id)
)

CREATE UNIQUE INDEX IU_dbo_foo_parent_id ON dbo.foo(parent_id)
```

Корректно

```sql
CREATE TABLE dbo.foo
(
    id          INT NOT NULL PRIMARY KEY
    , parent_id INT NOT NULL -- not null no default
    , UNIQUE (parent_id)
    , INDEX IU_dbo_foo_parent_id UNIQUE (parent_id)
)

CREATE UNIQUE INDEX IU_dbo_foo_parent_id ON dbo.foo(parent_id)
```

## Подсказки

💡 Возможно, проблема не в индексе, а в определении поля или в выбранном подходе к реализации задачи.

💡 Удалить ограничение DEFAULT, но оставить поле таким же неселективным не решит проблему, на которую указывает линтер.
