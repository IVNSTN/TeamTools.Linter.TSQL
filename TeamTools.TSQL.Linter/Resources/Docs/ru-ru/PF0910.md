
# Индексация столбца, допускающего NULL или имеющего значение по умолчанию

|||
|-|-|
| Id | **PF0910**
| Мнемо | INDEXING_COL_WITH_DEFAULT
| Серьёзность | ℹ Подсказка
| Категория | [Производительность](./Категория_Производительность.md), [Индексы](./Группа_Индексы.md)
| Исходный код | [UniqueIndexOnColumnWithDefaultRule.cs](../../../Rules/Performance/UniqueIndexOnColumnWithDefaultRule.cs)

## Причина

Правило срабатывает, если в индексе используется столбец, имеющий значение по умолчанию или допускающий `NULL`, и это значение не отфильтровано.
<p id="descr">Отфильтруйте значения по умолчанию.</p>

## Примеры

Некорректно

```sql
CREATE TABLE dbo.foo
(
    id          INT NOT NULL PRIMARY KEY
    , parent_id INT NOT NULL DEFAULT 0
    , UNIQUE (parent_id)
)

CREATE UNIQUE INDEX IU_dbo_foo_parent_id ON dbo.foo(parent_id)
```

Корректно

```sql
CREATE TABLE dbo.foo
(
    id          INT NOT NULL PRIMARY KEY
    , parent_id INT NOT NULL -- not null no default
    , UNIQUE (parent_id)
    , INDEX IU_dbo_foo_parent_id UNIQUE (parent_id)
)

CREATE UNIQUE INDEX IU_dbo_foo_parent_id ON dbo.foo(parent_id)
```

## Подсказки

💡 Если у столбца есть типовое значение, то индекс по этому столбцу будет иметь плохую селективность. Если исключить из индексации строки с типовым значением, то индекс станет гораздо более полезным.

💡 Возможно, проблема не в индексе, а в определении столбца или в выбранном подходе к реализации задачи.

💡 Удалить ограничение `DEFAULT`, но оставить столбец таким же неселективным, не решит проблему, на которую указывает линтер.
