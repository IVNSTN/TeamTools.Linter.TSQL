
# Неоптимальный предикат

|||
|-|-|
| Id | **PF0929**
| Мнемо | NON_SARGABLE_PREDICATE
| Серьёзность | ℹ Подсказка
| Категория | [Производительность](./Категория_Производительность.md)
| Исходный код | [NonSargablePredicateRule.cs](../../../Rules/Performance/NonSargablePredicateRule.cs)

## Причина

Правило срабатывает, если обнаружены предикаты фильтрации (`WHERE`) и объединения (`JOIN`), которые не могут быть эффективно вычислены и применены к существующим индексам.
<p id="descr">Перепишите предикат, чтобы он мог быть применен к существующим индексам.</p>

## Примеры

Некорректно

```sql
-- Вычисления в предикатах:
SELECT
    ft.id
    , ft.val
FROM dbo.foo AS ft
INNER JOIN dbo.bar AS bt
    ON bt.id = ft.id + 1 -- здесь
WHERE (ft.num - bt.num) = 0; -- здесь

DELETE bt
FROM dbo.foo AS ft
INNER JOIN dbo.bar AS bt
    ON bt.id = CASE WHEN ft.parent_id IS NULL THEN bt.id ELSE ft.parent_id END -- здесь, выражение CASE
WHERE ft.num = IIF(1 = 0, bt.num, NULL); -- здесь, функция IIF

-- Вызов пользовательской функции:
SELECT
    ft.id
    , bt.val
FROM dbo.foo AS ft
INNER JOIN dbo.bar AS bt
    ON ft.id > dbo.min_id() -- здесь, функция min_id()
WHERE ft.date_open BETWEEN dbo.yesterday() AND GETDATE(); -- здесь, функция yesterday()

-- Преобразование типов:
SELECT
    ft.id
    , bt.val
FROM dbo.foo AS ft
INNER JOIN dbo.bar AS bt
    ON bt.id = CAST(ft.id AS BIGINT) -- здесь
WHERE TRY_CONVERT(DATE, ft.num) > 0; -- здесь

-- Работа с NULL:
SELECT
    ft.id
    , bt.val
FROM dbo.foo AS ft
INNER JOIN dbo.bar AS bt
    ON ISNULL(ft.id, 0) <> bt.id -- здесь
WHERE NULLIF(t.title, '') <> ''; -- здесь
```

## Подсказка

💡 Это в том числе:

- Вызовы недетерминированных или зависящих от значений столбцов таблиц из выборки функций
- Cравнения, основанные на вычислениях с использованием значений столбцов, на преобразованиях значений столбцов
- Логическое ИЛИ, примененное к фильтру по столбцу
- `ISNULL`, `NULLIF`, `COALESCE`, `CAST`, `CONVERT`, примененные к столбцу таблицы

💡 Исправляется в том числе:

- Предварительным преобразованием, предварительным накоплением фрагментов данных во временных таблицах
- Раскрытием функции в `APPLY`
- Изменением `ISNULL`, `NULLIF` в `OR`, который тоже плохой, но может исправляться перекомпиляцией или указаниями `OPTIMIZE FOR`
- Фильтрованными индексами
- Декомпозицией сложного запроса в несколько простых
- И другими способами.

💡 Массовая проверка отличия всего от всех с учетом `NULL` как самостоятельного значения может быть выполнена через `EXCEPT`. Проверка полного совпадения - через `INTERSECT`.
